{"ast":null,"code":"var _jsxFileName = \"/Users/morarualexandru/Desktop/OV landing/ovw/src/components/Page.tsx\",\n    _s = $RefreshSig$();\n\nimport * as React from \"react\";\nimport { motion, useMotionValue, MotionValue } from \"framer-motion\";\nimport { defaultEffects } from \"./default-effects\";\n/**\n * The size of the page component.\n */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\n/**\n * Page\n *\n * @public\n */\nexport const Page = /*#__PURE__*/_s( /*#__PURE__*/React.forwardRef(_c = _s((props, forwardedRef) => {\n  _s();\n\n  const {\n    currentPage = 0,\n    gap = 0,\n    direction = \"horizontal\",\n    transition = {\n      duration: 0.5,\n      type: \"spring\",\n      damping: 100,\n      stiffness: 100,\n      mass: 1.0\n    },\n    originX = 0,\n    originY = 0,\n    dragElastic = 0.75,\n    contentOffset,\n    motionPage,\n    progress,\n    effect,\n    onChangePage,\n    children,\n    ...rest\n  } = props;\n  const isHorizontal = React.useMemo(() => direction === \"horizontal\", [direction]);\n  const pageCount = React.useMemo(() => React.Children.count(children), [children]); // ------------------------------ Refs -----------------------------------\n\n  const rPrevious = React.useRef(-1);\n  const rDragging = React.useRef(false);\n  const rContainer = React.useRef(null);\n  const rDraggable = React.useRef(null); // ----------------------------- State ----------------------------------\n\n  const [originOffset, setOriginOffset] = React.useState({\n    x: 0,\n    y: 0\n  });\n  const [size, setSize] = React.useState({\n    width: 0,\n    height: 0\n  });\n  const [pages, setPages] = React.useState(children);\n  const [current, setCurrent] = React.useState(currentPage); // ------------------------- Motion Values -------------------------------\n\n  const wrapperOffset = useMotionValue(-((isHorizontal ? size.width : size.height) + gap) * currentPage);\n  const draggableOffset = useMotionValue(0);\n  const mvContentOffset = useMotionValue(wrapperOffset.get()); // --------------------------- Callbacks ---------------------------------\n\n  const runPageEffects = React.useCallback(function (offset, step, pageCount) {\n    if (effect === undefined) return;\n    const origin = isHorizontal ? originOffset.x : originOffset.y;\n    const pages = React.Children.map(children, (child, index) => {\n      let e = typeof effect === \"string\" ? defaultEffects[effect] : effect;\n      const normalizedOffset = (offset - origin + index * step) / step;\n      const effectProps = e({\n        index,\n        pageCount,\n        direction,\n        offset,\n        normalizedOffset,\n        size,\n        gap\n      }) || {};\n\n      if ( /*#__PURE__*/React.isValidElement(child)) {\n        return /*#__PURE__*/React.cloneElement(child, { ...child.props,\n          ...effectProps,\n          style: { ...child.props.style,\n            ...effectProps.style\n          }\n        });\n      }\n    });\n    setPages(pages);\n  }, [children, direction, effect, gap, size]); // ----------------------------- Effects ---------------------------------\n  // Set size from container offsets\n\n  React.useLayoutEffect(() => {\n    const draggable = rDraggable.current;\n    const container = rContainer.current;\n\n    if (draggable !== null && container !== null) {\n      const contentSize = isHorizontal ? {\n        width: (draggable.offsetWidth + gap) / pageCount - gap,\n        height: draggable.offsetHeight\n      } : {\n        width: draggable.offsetWidth,\n        height: (draggable.offsetHeight + gap) / pageCount - gap\n      };\n      setSize(contentSize);\n      setOriginOffset({\n        x: (container.offsetWidth - contentSize.width) * originX,\n        y: (container.offsetHeight - contentSize.height) * originY\n      });\n    }\n  }, [isHorizontal, originX, originY, pageCount, gap]); // ---------- Current Page\n  // Update current when currentPage changes\n\n  React.useEffect(() => {\n    if (currentPage <= pageCount - 1 && currentPage >= 0) {\n      setCurrent(current => {\n        rPrevious.current = current;\n        return currentPage;\n      });\n    }\n  }, [currentPage, pageCount]); // ---------- Content Offsets\n  // Update mvContentOffset when dragging\n\n  React.useEffect(() => {\n    return draggableOffset.onChange(v => {\n      mvContentOffset.set(v + wrapperOffset.get());\n    });\n  }, [draggableOffset, mvContentOffset, wrapperOffset]); // Update mvContentOffset when not dragging\n\n  React.useEffect(() => {\n    return wrapperOffset.onChange(v => {\n      if (rDragging.current) return;\n      mvContentOffset.set(v + draggableOffset.get());\n    });\n  }, [draggableOffset, mvContentOffset, wrapperOffset]); // Update contentOffset when mvContentOffset changes\n\n  React.useEffect(() => {\n    if (contentOffset instanceof MotionValue) {\n      return mvContentOffset.onChange(v => {\n        contentOffset.set(mvContentOffset.get());\n      });\n    }\n  }, [contentOffset, mvContentOffset]); // ---------- Progress / Motionpage / Page Effects\n  // Update motion values when mvContentOffset changes\n\n  React.useEffect(() => {\n    return mvContentOffset.onChange(offset => {\n      const step = size.width + gap; // Update motionPage\n\n      if (motionPage instanceof MotionValue) {\n        motionPage.set(-offset / step);\n      } // Update progress\n\n\n      if (progress instanceof MotionValue) {\n        progress.set(-offset / step / (pageCount - 1));\n      } // Update pages (page effects)\n\n\n      runPageEffects(offset, step, pageCount);\n    });\n  }, [runPageEffects, motionPage, progress, mvContentOffset, direction, effect, gap, size, pageCount]); // Update pages (page effects) on load\n\n  React.useLayoutEffect(() => {\n    const offset = mvContentOffset.get();\n    const step = size.width + gap;\n    runPageEffects(offset, pageCount, step);\n  }, [effect, gap, mvContentOffset, runPageEffects, pageCount, size.width]); // --------------------------- Callbacks -------------------------------\n  // Set dragging ref to true\n\n  const handleDragStart = React.useCallback(() => {\n    rDragging.current = true;\n  }, []); // Check whether drag caused a page change\n\n  const handleDragEnd = React.useCallback((event, info) => {\n    rDragging.current = false;\n    const {\n      velocity,\n      offset\n    } = info;\n    let vel, off, dim;\n\n    if (isHorizontal) {\n      off = offset.x;\n      vel = velocity.x;\n      dim = size.width;\n    } else {\n      off = offset.y;\n      vel = velocity.y;\n      dim = size.height;\n    }\n\n    const farEnough = Math.abs(off) > dim / 4;\n    const fastEnough = Math.abs(vel) > 75;\n\n    if (farEnough || fastEnough) {\n      const delta = off > 0 ? -1 : 1;\n      const next = current + delta;\n      const max = pageCount - 1;\n\n      if (next !== current) {\n        rPrevious.current = current;\n        setCurrent(Math.max(0, Math.min(max, next)));\n        onChangePage && onChangePage(next, rPrevious.current);\n      }\n    }\n  }, [isHorizontal, pageCount, size, current, setCurrent, onChangePage]); // ------------------------------ JSX ---------------------------------\n\n  return /*#__PURE__*/_jsxDEV(motion.div, {\n    ref: forwardedRef,\n    ...rest,\n    children: /*#__PURE__*/_jsxDEV(motion.div, {\n      ref: rContainer,\n      initial: false,\n      style: {\n        display: \"flex\",\n        alignItems: \"flex-start\",\n        justifyContent: \"flex-start\",\n        flexDirection: isHorizontal ? \"row\" : \"column\",\n        // transformStyle: \"preserve-3d\",\n        height: \"100%\",\n        width: \"100%\",\n        ...(isHorizontal ? {\n          x: wrapperOffset,\n          y: 0\n        } : {\n          x: 0,\n          y: wrapperOffset\n        })\n      },\n      animate: {\n        x: isHorizontal ? originOffset.x - (size.width + gap) * current : originOffset.x,\n        y: isHorizontal ? originOffset.y : originOffset.y - (size.height + gap) * current\n      },\n      transition: {\n        duration: 0.5\n      },\n      children: /*#__PURE__*/_jsxDEV(motion.div, {\n        ref: rDraggable,\n        style: {\n          display: \"grid\",\n          gridAutoColumns: \"auto\",\n          gridAutoRows: \"auto\",\n          gridAutoFlow: isHorizontal ? \"column\" : \"row\",\n          gap,\n          // transformStyle: \"preserve-3d\",\n          width: \"auto\",\n          ...(isHorizontal ? {\n            x: draggableOffset\n          } : {\n            y: draggableOffset\n          })\n        },\n        drag: isHorizontal ? \"x\" : \"y\" // dragElastic={dragElastic}\n        ,\n        dragConstraints: {\n          left: 0,\n          right: 0,\n          top: 0,\n          bottom: 0\n        },\n        initial: false,\n        onDragStart: handleDragStart,\n        onDragEnd: handleDragEnd,\n        children: pages\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 386,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 361,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 351,\n    columnNumber: 7\n  }, this);\n}, \"SXMIy8KpzowTUIremWy0tKJnaKQ=\", false, function () {\n  return [useMotionValue, useMotionValue, useMotionValue];\n})), \"SXMIy8KpzowTUIremWy0tKJnaKQ=\", false, function () {\n  return [useMotionValue, useMotionValue, useMotionValue];\n});\n_c2 = Page;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Page$React.forwardRef\");\n$RefreshReg$(_c2, \"Page\");","map":{"version":3,"sources":["/Users/morarualexandru/Desktop/OV landing/ovw/src/components/Page.tsx"],"names":["React","motion","useMotionValue","MotionValue","defaultEffects","Page","forwardRef","props","forwardedRef","currentPage","gap","direction","transition","duration","type","damping","stiffness","mass","originX","originY","dragElastic","contentOffset","motionPage","progress","effect","onChangePage","children","rest","isHorizontal","useMemo","pageCount","Children","count","rPrevious","useRef","rDragging","rContainer","rDraggable","originOffset","setOriginOffset","useState","x","y","size","setSize","width","height","pages","setPages","current","setCurrent","wrapperOffset","draggableOffset","mvContentOffset","get","runPageEffects","useCallback","offset","step","undefined","origin","map","child","index","e","normalizedOffset","effectProps","isValidElement","cloneElement","style","useLayoutEffect","draggable","container","contentSize","offsetWidth","offsetHeight","useEffect","onChange","v","set","handleDragStart","handleDragEnd","event","info","velocity","vel","off","dim","farEnough","Math","abs","fastEnough","delta","next","max","min","display","alignItems","justifyContent","flexDirection","gridAutoColumns","gridAutoRows","gridAutoFlow","left","right","top","bottom"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n  motion,\n  useMotionValue,\n  MotionValue,\n  HTMLMotionProps,\n  PanInfo,\n} from \"framer-motion\";\nimport { defaultEffects } from \"./default-effects\";\n\n/**\n * The size of the page component.\n */\nexport type Size = { width: number; height: number };\n\n/**\n * A union of default page effects.\n */\nexport type DefaultEffect = \"coverflow\" | \"pile\" | \"cube\" | \"wheel\" | \"titles\";\n\n/** The type of the options passed into a PageEffect function. */\nexport type PageEffectInfo = {\n  index: number;\n  pageCount: number;\n  direction: \"horizontal\" | \"vertical\";\n  offset: number;\n  normalizedOffset: number;\n  size: Size;\n  gap: number;\n};\n\n/**\n * A function that updates each page as the component changes pages.\n */\nexport type PageEffect = (\n  info: PageEffectInfo\n) => Partial<HTMLMotionProps<\"div\">>;\n\n/**\n * Props for `Page` component.\n */\nexport type PageProps = Partial<{\n  /**\n   * Distance (in pixels) between each page.\n   */\n  gap: number;\n  /**\n   * The page index to display or turn to.\n   */\n  currentPage: number;\n  /**\n   * Whether the page component should turn in the vertical or horizontal direction.\n   */\n  direction: \"horizontal\" | \"vertical\";\n  /**\n   * Where to align the pages along the horizontal axis.\n   */\n  originX: number;\n  /**\n   * Where to align the pages along the vertical axis.\n   */\n  originY: number;\n  /**\n   * A named default effect (\"pile\", \"coverflow\", \"cube\", or \"wheel\") or a PageEffect function.\n   */\n  effect: DefaultEffect | PageEffect;\n  /**\n   * A motion value that is updated with the offset (x or y, depending on direction) of the component's content.\n   */\n  contentOffset: MotionValue<number>;\n  /**\n   * A motion value that is updated with the component's current page as a floating point (e.g. 1.5 when half-way between the second and third page).\n   */\n  motionPage: MotionValue<number>;\n  /**\n   * A motion value that is updated with the normalized progress of the component as it moves from start to end (e.g. 0 at the first page and 1 at the last).\n   */\n  progress: MotionValue<number>;\n  /**\n   * An event that is triggered any time the user changes the current page through a swipe gesture.\n   */\n  onChangePage: (currentPage: number, previousPage: number) => void;\n}> &\n  HTMLMotionProps<\"div\">;\n\n/**\n * Page\n *\n * @public\n */\nexport const Page = React.forwardRef<HTMLDivElement, PageProps>(\n  (props, forwardedRef) => {\n    const {\n      currentPage = 0,\n      gap = 0,\n      direction = \"horizontal\",\n      transition = {\n        duration: 0.5,\n        type: \"spring\",\n        damping: 100,\n        stiffness: 100,\n        mass: 1.0,\n      },\n      originX = 0,\n      originY = 0,\n      dragElastic = 0.75,\n      contentOffset,\n      motionPage,\n      progress,\n      effect,\n      onChangePage,\n      children,\n      ...rest\n    } = props;\n\n    const isHorizontal = React.useMemo(\n      () => direction === \"horizontal\",\n      [direction]\n    );\n\n    const pageCount = React.useMemo(\n      () => React.Children.count(children),\n      [children]\n    );\n\n    // ------------------------------ Refs -----------------------------------\n\n    const rPrevious = React.useRef(-1);\n    const rDragging = React.useRef(false);\n    const rContainer = React.useRef<HTMLDivElement>(null);\n    const rDraggable = React.useRef<HTMLDivElement>(null);\n\n    // ----------------------------- State ----------------------------------\n\n    const [originOffset, setOriginOffset] = React.useState({\n      x: 0,\n      y: 0,\n    });\n\n    const [size, setSize] = React.useState<Size>({\n      width: 0,\n      height: 0,\n    });\n\n    const [pages, setPages] = React.useState(children);\n\n    const [current, setCurrent] = React.useState(currentPage);\n\n    // ------------------------- Motion Values -------------------------------\n\n    const wrapperOffset = useMotionValue(\n      -((isHorizontal ? size.width : size.height) + gap) * currentPage\n    );\n\n    const draggableOffset = useMotionValue(0);\n\n    const mvContentOffset = useMotionValue(wrapperOffset.get());\n\n    // --------------------------- Callbacks ---------------------------------\n\n    const runPageEffects = React.useCallback(\n      function (offset: number, step: number, pageCount: number) {\n        if (effect === undefined) return;\n\n        const origin = isHorizontal ? originOffset.x : originOffset.y;\n\n        const pages = React.Children.map(children, (child, index) => {\n          let e = typeof effect === \"string\" ? defaultEffects[effect] : effect;\n\n          const normalizedOffset = (offset - origin + index * step) / step;\n\n          const effectProps =\n            e({\n              index,\n              pageCount,\n              direction,\n              offset,\n              normalizedOffset,\n              size,\n              gap,\n            }) || {};\n\n          if (React.isValidElement(child)) {\n            return React.cloneElement(child, {\n              ...child.props,\n              ...effectProps,\n              style: {\n                ...child.props.style,\n                ...effectProps.style,\n              },\n            });\n          }\n        });\n\n        setPages(pages);\n      },\n      [children, direction, effect, gap, size]\n    );\n\n    // ----------------------------- Effects ---------------------------------\n\n    // Set size from container offsets\n    React.useLayoutEffect(() => {\n      const draggable = rDraggable.current;\n      const container = rContainer.current;\n\n      if (draggable !== null && container !== null) {\n        const contentSize = isHorizontal\n          ? {\n              width: (draggable.offsetWidth + gap) / pageCount - gap,\n              height: draggable.offsetHeight,\n            }\n          : {\n              width: draggable.offsetWidth,\n              height: (draggable.offsetHeight + gap) / pageCount - gap,\n            };\n\n        setSize(contentSize);\n\n        setOriginOffset({\n          x: (container.offsetWidth - contentSize.width) * originX,\n          y: (container.offsetHeight - contentSize.height) * originY,\n        });\n      }\n    }, [isHorizontal, originX, originY, pageCount, gap]);\n\n    // ---------- Current Page\n\n    // Update current when currentPage changes\n    React.useEffect(() => {\n      if (currentPage <= pageCount - 1 && currentPage >= 0) {\n        setCurrent((current) => {\n          rPrevious.current = current;\n          return currentPage;\n        });\n      }\n    }, [currentPage, pageCount]);\n\n    // ---------- Content Offsets\n\n    // Update mvContentOffset when dragging\n    React.useEffect(() => {\n      return draggableOffset.onChange((v) => {\n        mvContentOffset.set(v + wrapperOffset.get());\n      });\n    }, [draggableOffset, mvContentOffset, wrapperOffset]);\n\n    // Update mvContentOffset when not dragging\n    React.useEffect(() => {\n      return wrapperOffset.onChange((v) => {\n        if (rDragging.current) return;\n\n        mvContentOffset.set(v + draggableOffset.get());\n      });\n    }, [draggableOffset, mvContentOffset, wrapperOffset]);\n\n    // Update contentOffset when mvContentOffset changes\n    React.useEffect(() => {\n      if (contentOffset instanceof MotionValue) {\n        return mvContentOffset.onChange((v) => {\n          contentOffset.set(mvContentOffset.get());\n        });\n      }\n    }, [contentOffset, mvContentOffset]);\n\n    // ---------- Progress / Motionpage / Page Effects\n\n    // Update motion values when mvContentOffset changes\n    React.useEffect(() => {\n      return mvContentOffset.onChange((offset) => {\n        const step = size.width + gap;\n\n        // Update motionPage\n        if (motionPage instanceof MotionValue) {\n          motionPage.set(-offset / step);\n        }\n\n        // Update progress\n        if (progress instanceof MotionValue) {\n          progress.set(-offset / step / (pageCount - 1));\n        }\n\n        // Update pages (page effects)\n        runPageEffects(offset, step, pageCount);\n      });\n    }, [\n      runPageEffects,\n      motionPage,\n      progress,\n      mvContentOffset,\n      direction,\n      effect,\n      gap,\n      size,\n      pageCount,\n    ]);\n\n    // Update pages (page effects) on load\n    React.useLayoutEffect(() => {\n      const offset = mvContentOffset.get();\n      const step = size.width + gap;\n      runPageEffects(offset, pageCount, step);\n    }, [effect, gap, mvContentOffset, runPageEffects, pageCount, size.width]);\n\n    // --------------------------- Callbacks -------------------------------\n\n    // Set dragging ref to true\n    const handleDragStart = React.useCallback(() => {\n      rDragging.current = true;\n    }, []);\n\n    // Check whether drag caused a page change\n    const handleDragEnd = React.useCallback(\n      (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {\n        rDragging.current = false;\n\n        const { velocity, offset } = info;\n        let vel, off, dim;\n\n        if (isHorizontal) {\n          off = offset.x;\n          vel = velocity.x;\n          dim = size.width;\n        } else {\n          off = offset.y;\n          vel = velocity.y;\n          dim = size.height;\n        }\n\n        const farEnough = Math.abs(off) > dim / 4;\n        const fastEnough = Math.abs(vel) > 75;\n\n        if (farEnough || fastEnough) {\n          const delta = off > 0 ? -1 : 1;\n          const next = current + delta;\n          const max = pageCount - 1;\n\n          if (next !== current) {\n            rPrevious.current = current;\n            setCurrent(Math.max(0, Math.min(max, next)));\n            onChangePage && onChangePage(next, rPrevious.current);\n          }\n        }\n      },\n      [isHorizontal, pageCount, size, current, setCurrent, onChangePage]\n    );\n\n    // ------------------------------ JSX ---------------------------------\n\n    return (\n      <motion.div\n        ref={forwardedRef}\n        {...rest}\n        // style={{\n        //   transformStyle: \"preserve-3d\",\n        //   perspective: 1200,\n        //   overflow: \"hidden\",\n        //   ...rest.style,\n        // }}\n      >\n        <motion.div\n          ref={rContainer}\n          initial={false}\n          style={{\n            display: \"flex\",\n            alignItems: \"flex-start\",\n            justifyContent: \"flex-start\",\n            flexDirection: isHorizontal ? \"row\" : \"column\",\n            // transformStyle: \"preserve-3d\",\n            height: \"100%\",\n            width: \"100%\",\n            ...(isHorizontal\n              ? { x: wrapperOffset, y: 0 }\n              : { x: 0, y: wrapperOffset }),\n          }}\n          animate={{\n            x: isHorizontal\n              ? originOffset.x - (size.width + gap) * current\n              : originOffset.x,\n            y: isHorizontal\n              ? originOffset.y\n              : originOffset.y - (size.height + gap) * current,\n          }}\n          transition={{ duration: 0.5 }}\n        >\n          <motion.div\n            ref={rDraggable}\n            style={{\n              display: \"grid\",\n              gridAutoColumns: \"auto\",\n              gridAutoRows: \"auto\",\n              gridAutoFlow: isHorizontal ? \"column\" : \"row\",\n              gap,\n              // transformStyle: \"preserve-3d\",\n              width: \"auto\",\n              ...(isHorizontal\n                ? { x: draggableOffset }\n                : { y: draggableOffset }),\n            }}\n            drag={isHorizontal ? \"x\" : \"y\"}\n            // dragElastic={dragElastic}\n            dragConstraints={{\n              left: 0,\n              right: 0,\n              top: 0,\n              bottom: 0,\n            }}\n            initial={false}\n            onDragStart={handleDragStart}\n            onDragEnd={handleDragEnd}\n          >\n            {pages}\n          </motion.div>\n        </motion.div>\n      </motion.div>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}